[
  {
    "instance_id": "instance_0",
    "gql_query": "MATCH (c:COUNTRY)-[s:Speaks]->(l:LANGUAGE) WHERE s.percentage > 50 RETURN c, l",
    "initial_nl": "Is there a language spoken in more than 50% of the population in any country? Return the city and the language.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all COUNTRY nodes connected by a Speaks relationship to LANGUAGE nodes where the relationship's percentage property is greater than 50, and return both the country and language nodes.",
    "level_2": "Which countries have a language spoken by more than 50% of their population, and what is that language?",
    "level_3": "Identify dominant languages within countries by analyzing linguistic distribution data to determine thresholds of majority usage.",
    "level_4": "Support language policy decisions or localization strategies by identifying countries where a single language holds significant majority status among the population.",
    "explanation": "The initial NL query focuses on the semantic meaning of the GQL without using graph-specific terms like 'nodes' or 'relationships', placing it at Level 2. Level 1 reintroduces explicit structural elements (node labels, relationship types, properties). Level 3 shifts to an analytical perspective, emphasizing the methodology of detecting dominant languages through threshold-based analysis. Level 4 elevates the insight to real-world applications, such as informing governmental policy or business localization efforts, highlighting strategic value.",
    "meta": {},
    "initial_query": "MATCH (c:CITY)-[:LocatedIn]->(co:COUNTRY), (co)<-[:Speaks]-(l:LANGUAGE)\nWHERE l.percentage > 50.0\nRETURN DISTINCT c.name AS city, l.name AS language",
    "level_1_query": "MATCH (c:COUNTRY)-[r:Speaks]->(l:LANGUAGE)\nWHERE r.percentage > 50\nRETURN DISTINCT c, l",
    "level_2_query": "MATCH (c:COUNTRY)-[s:SPEAKS]->(l:LANGUAGE)\nWHERE s.percentage > 50\nRETURN DISTINCT c.name AS country, l.name AS language",
    "level_3_query": "MATCH (c:COUNTRY)-[s:SPEAKS]->(l:LANGUAGE)\nWITH c, l, s.percentage AS percentage\nORDER BY percentage DESC\nWITH c, collect(l)[0] AS dominant_language\nRETURN c.name AS country, dominant_language.name AS dominant_language;",
    "level_4_query": "MATCH (c:COUNTRY)-[s:SPEAKS]->(l:LANGUAGE)\nWITH c, l, s.percentage AS pct\nWHERE pct IS NOT NULL\nORDER BY pct DESC\nWITH c, COLLECT(l)[0] AS dominant_language, COLLECT(pct)[0] AS max_percentage\nWHERE max_percentage > 70\nRETURN DISTINCT c.name AS country, dominant_language.name AS dominant_language, max_percentage AS percentage"
  },
  {
    "instance_id": "instance_1",
    "gql_query": "MATCH (c:CITY)-[h:HasEthnicGroup]->(e:ETHNICITY) RETURN count(e) AS ethnic_group_count, avg(h.percentage) AS average_percentage",
    "initial_nl": "How many ethnic groups are present in each city, and what is the average percentage of the population for each ethnic group across all cities?",
    "initial_nl_classification": "Level 2",
    "level_1": "For each city node connected via a 'HasEthnicGroup' relationship to an ethnicity node, return the count of ethnicity nodes and the average value of the 'percentage' property on those relationships.",
    "level_2": "What is the total number of ethnic groups across all cities, and what is the average population percentage of these ethnic groups?",
    "level_3": "Analyze demographic diversity across cities by aggregating the number of represented ethnic groups and calculating the mean population share to identify overall patterns in multicultural distribution.",
    "level_4": "Support urban policy and resource allocation decisions by assessing the extent and scale of ethnic diversity across cities to promote inclusive community planning and services.",
    "explanation": "The initial natural language query focuses on the semantic meaning of the data (counting ethnic groups and averaging percentages) without referencing graph structures like nodes or relationships, placing it at Level 2. Level 1 explicitly describes the graph elements (CITY, ETHNICITY, HasEthnicGroup, percentage property). Level 2 rephrases this into a clear, non-technical question about the data. Level 3 shifts to the analytical intent—understanding patterns in demographic diversity. Level 4 elevates the purpose to strategic, real-world impact in urban planning and social equity, showing a progression from syntax to significance.",
    "meta": {},
    "initial_query": "MATCH (c:CITY)-[r:HasEthnicGroup]->(e:ETHNICITY)\nRETURN c.name AS city_name, COUNT(e) AS ethnic_group_count, AVG(r.percentage) AS average_percentage",
    "level_1_query": "MATCH (c:CITY)-[r:HasEthnicGroup]->(e:ETHNICITY)\nRETURN c.city_id, count(e) AS ethnicity_count, avg(r.percentage) AS average_percentage",
    "level_2_query": "MATCH (c:CITY)<-[:HasEthnicGroup]-(e:ETHNICITY)\nRETURN COUNT(DISTINCT e) AS total_ethnic_groups, AVG(e.percentage) AS average_percentage",
    "level_3_query": "MATCH (c:CITY)-[r:HasEthnicGroup]->(e:ETHNICITY)\nRETURN c.name AS city, COUNT(e) AS num_ethnic_groups, AVG(r.percentage) AS mean_population_share\nORDER BY num_ethnic_groups DESC, mean_population_share DESC",
    "level_4_query": "MATCH (c:CITY)-[:HasEthnicGroup]->(e:ETHNICITY)\nRETURN c.name AS city, COUNT(DISTINCT e) AS ethnic_diversity_count\nORDER BY ethnic_diversity_count DESC;"
  },
  {
    "instance_id": "instance_2",
    "gql_query": "MATCH (l:LAKE) WHERE l.max_depth > 100 AND l.area > 500 RETURN l ORDER BY l.max_depth DESC",
    "initial_nl": "Find lakes with a maximum depth greater than 100 meters and an area larger than 500 square kilometers, ordered by maximum depth from deepest to shallowest.",
    "initial_nl_classification": "Level 2",
    "level_1": "Retrieve all 'LAKE' nodes in the graph where the 'max_depth' property is greater than 100 and the 'area' property exceeds 500, then return these nodes ordered by the 'max_depth' property in descending order.",
    "level_2": "Find lakes with a maximum depth greater than 100 meters and an area larger than 500 square kilometers, sorted from deepest to shallowest.",
    "level_3": "Identify and prioritize large, deep lakes to support hydrological studies focusing on water volume, thermal stratification, or ecosystem resilience in major freshwater bodies.",
    "level_4": "Support environmental conservation planning by highlighting significant lakes that may serve as critical water resources or biodiversity hotspots requiring targeted protection and management.",
    "explanation": "The progression moves from explicit graph syntax (Level 1: node labels and properties) to semantic clarity without technical terms (Level 2). Level 3 introduces the analytical intent—studying key physical characteristics of lakes for scientific insight. Level 4 elevates the purpose to real-world impact, emphasizing strategic environmental management and resource prioritization, thus reflecting increasing abstraction and domain relevance.",
    "meta": {},
    "initial_query": "MATCH (l:LAKE)\nWHERE l.max_depth > 100 AND l.area > 500\nRETURN l.name, l.max_depth, l.area\nORDER BY l.max_depth DESC",
    "level_1_query": "MATCH (l:LAKE)\nWHERE l.max_depth > 100 AND l.area > 500\nRETURN l\nORDER BY l.max_depth DESC",
    "level_2_query": "MATCH (l:LAKE)\nWHERE l.max_depth > 100 AND l.area > 500\nRETURN l.name, l.max_depth, l.area\nORDER BY l.max_depth DESC",
    "level_3_query": "MATCH (l:LAKE)\nWHERE l.area IS NOT NULL AND l.max_depth IS NOT NULL\nRETURN l.lake_id, l.name, l.area, l.max_depth\nORDER BY l.area * l.max_depth DESC",
    "level_4_query": "MATCH (l:LAKE)\nWHERE l.area > 1000\nRETURN l.lake_id, l.name, l.area, l.max_depth\nORDER BY l.area DESC"
  },
  {
    "instance_id": "instance_3",
    "gql_query": "MATCH (r1:RIVER)-[:FlowsInto]->(s:SEA)<-[:FlowsInto]-(r2:RIVER) WHERE r1.river_id <> r2.river_id RETURN r1.name AS river1_name, r2.name AS river2_name, s.name AS sea_name",
    "initial_nl": "Which two rivers flow into the same sea, and what are their names and the seas's name?",
    "initial_nl_classification": "Level 2",
    "level_1": "Find pairs of river nodes (r1:RIVER and r2:RIVER) that are connected via a FlowsInto relationship to the same sea node (s:SEA), where r1.river_id is not equal to r2.river_id, and return the names of r1, r2, and s.",
    "level_2": "Which two different rivers flow into the same sea, and what are the names of those rivers and the sea?",
    "level_3": "Identify co-destination patterns among rivers by analyzing which pairs share a common terminal sea, excluding self-pairs, to study hydrological convergence and potential basin interdependencies.",
    "level_4": "Support environmental planning and water resource management by revealing river systems that converge in the same sea, helping assess cumulative ecological impacts, pollution risks, or transboundary water governance needs.",
    "explanation": "The initial NL query focuses on the semantic meaning of the data without referencing graph structures (e.g., nodes, relationships), placing it at Level 2. Level 1 explicitly describes the graph syntax—node labels, relationship types, and filtering conditions. Level 2 rephrases this into natural language understandable to non-technical users, focusing on 'which rivers flow into the same sea.' Level 3 elevates the description to an analytical perspective, emphasizing the investigation of hydrological patterns and systemic relationships. Finally, Level 4 connects the query to real-world applications in environmental science and policy, highlighting strategic value in managing shared marine ecosystems.",
    "meta": {},
    "initial_query": "MATCH (r1:RIVER)-[:FLOWS_INTO]->(s:SEA)<-[:FLOWS_INTO]-(r2:RIVER)\nWHERE r1.river_id < r2.river_id\nRETURN r1.name AS river1_name, r2.name AS river2_name, s.name AS sea_name",
    "level_1_query": "MATCH (r1:RIVER)-[:FlowsInto]->(s:SEA)<-[:FlowsInto]-(r2:RIVER)\nWHERE r1.river_id <> r2.river_id\nRETURN DISTINCT r1.name, r2.name, s.name",
    "level_2_query": "MATCH (r1:RIVER)-[:FlowsInto]->(s:SEA)<-[:FlowsInto]-(r2:RIVER)\nWHERE r1.river_id < r2.river_id\nRETURN r1.name AS river1_name, r2.name AS river2_name, s.name AS sea_name",
    "level_3_query": "MATCH (r1:RIVER)-[:FlowsInto]->(s:SEA)<-[:FlowsInto]-(r2:RIVER)\nWHERE r1.river_id < r2.river_id\nRETURN r1.name AS river1, r2.name AS river2, s.name AS common_sea\nORDER BY common_sea, river1, river2",
    "level_4_query": "MATCH (r:RIVER)-[:FLOWS_INTO]->(s:SEA)\nRETURN s.name AS sea, COLLECT(r.name) AS rivers\nORDER BY s.name"
  },
  {
    "instance_id": "instance_4",
    "gql_query": "MATCH (c:CITY)-[:LocatedIn]->(co:COUNTRY)-[:HasGovernment]->(g:GOVERNMENT_TYPE) WHERE c.population >= 1000000 AND c.population <= 5000000 AND g.name = 'Republic' RETURN c ORDER BY c.population ASC",
    "initial_nl": "List all cities with a population between 1 million and 5 million, located in countries with a government type of 'Republic', sorted by city population in ascending order.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all CITY nodes connected via a LocatedIn relationship to COUNTRY nodes, which are in turn connected by a HasGovernment relationship to GOVERNMENT_TYPE nodes where the name property is 'Republic', and where the CITY node has a population property between 1,000,000 and 5,000,000; return these CITY nodes ordered by their population in ascending order.",
    "level_2": "List all cities with a population between 1 million and 5 million that are located in countries with a government type of 'Republic', sorted by population from smallest to largest.",
    "level_3": "Identify mid-sized urban centers in republican-governed countries to analyze patterns in city size distribution within democratic political systems.",
    "level_4": "Support urban development policy and foreign investment planning by highlighting medium-population cities in stable republican nations that may offer strategic growth opportunities.",
    "explanation": "The progression moves from explicit graph syntax (Level 1: nodes, relationships, properties) to a clear semantic interpretation (Level 2: natural language without technical terms). Level 3 shifts to an analytical perspective, framing the query as part of a study on urban and political systems. Level 4 elevates the insight to strategic decision-making, emphasizing real-world applications in policy and investment—demonstrating increasing abstraction and domain relevance across levels.",
    "meta": {},
    "initial_query": "MATCH (c:CITY)-[:LocatedIn]->(co:COUNTRY)-[:HasGovernment]->(g:GOVERNMENT_TYPE)\nWHERE c.population >= 1000000 AND c.population <= 5000000 AND g.name = 'Republic'\nRETURN c.name AS city_name, c.population AS population, co.name AS country_name\nORDER BY c.population ASC",
    "level_1_query": "MATCH (city:CITY)-[:LocatedIn]->(country:COUNTRY)-[:HasGovernment]->(gov:GOVERNMENT_TYPE)\nWHERE gov.name = 'Republic' AND city.population >= 1000000 AND city.population <= 5000000\nRETURN city\nORDER BY city.population ASC",
    "level_2_query": "MATCH (c:CITY)-[:LocatedIn]->(:COUNTRY)-[:HasGovernment]->(:GOVERNMENT_TYPE {name: 'Republic'})\nWHERE c.population >= 1000000 AND c.population <= 5000000\nRETURN DISTINCT c.name, c.population\nORDER BY c.population ASC",
    "level_3_query": "MATCH (c:COUNTRY)-[:HasGovernment]->(g:GOVERNMENT_TYPE), (ci:CITY)-[:LocatedIn]->(c)\nWHERE g.name = 'Republic' AND ci.population >= 100000 AND ci.population <= 500000\nRETURN DISTINCT ci.name AS city_name, ci.population, c.name AS country_name\nORDER BY ci.population DESC",
    "level_4_query": "MATCH (c:CITY)-[:LocatedIn]->(co:COUNTRY)\nWHERE c.population > 100000 AND c.population < 500000\nAND co.government_type = 'Republic'\nRETURN DISTINCT c.name AS city_name, c.population, co.name AS country_name\nORDER BY c.population DESC"
  },
  {
    "instance_id": "instance_5",
    "gql_query": "MATCH (p1:PROVINCE)-[:Contains]->(b1:BOUNDARY), (p2:PROVINCE)-[:Contains]->(b2:BOUNDARY) WHERE b1.type = b2.type AND p1.province_id <> p2.province_id RETURN DISTINCT p1.name, p2.name",
    "initial_nl": "Identify any two provinces that contain the same type of boundary and list their names.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find pairs of province nodes connected via 'Contains' relationships to boundary nodes where the boundary types are equal but the provinces have different province IDs, and return the distinct names of these provinces.",
    "level_2": "Identify any two provinces that contain the same type of boundary and list their names.",
    "level_3": "Explore spatial or administrative patterns by detecting provinces that share boundary types, to investigate potential regional connectivity or geographic clustering in the dataset.",
    "level_4": "Support regional planning and infrastructure development by identifying provinces with similar border characteristics, which may indicate shared logistical challenges or opportunities for cross-regional coordination.",
    "explanation": "The initial NL query focuses on the semantic meaning of the query without referencing graph elements like nodes or relationships, placing it at Level 2. Level 1 explicitly includes graph syntax (node labels, relationship types, properties). Level 3 shifts to the analytical intent—using shared boundary types to explore geographic or administrative patterns. Level 4 elevates the purpose to strategic decision-making in regional policy and infrastructure, reflecting real-world impact in governance or urban planning.",
    "meta": {},
    "initial_query": "MATCH (p1:PROVINCE)-[:HasBoundaryWith]->(b:BOUNDARY)<-[:HasBoundaryWith]-(p2:PROVINCE)\nWHERE p1.province_id < p2.province_id\nRETURN DISTINCT p1.name, p2.name",
    "level_1_query": "MATCH (p1:PROVINCE)-[:Contains]->(b:BOUNDARY)<-[:Contains]-(p2:PROVINCE)\nWHERE p1.province_id <> p2.province_id\nRETURN DISTINCT p1.name, p2.name",
    "level_2_query": "MATCH (p1:PROVINCE)-[:HasBoundaryWith]->(b:BOUNDARY), (p2:PROVINCE)-[:HasBoundaryWith]->(b)\nWHERE p1.province_id < p2.province_id\nRETURN DISTINCT p1.name, p2.name",
    "level_3_query": "MATCH (p1:PROVINCE)-[:HasBoundaryWith]->(b:BOUNDARY)<-[:HasBoundaryWith]-(p2:PROVINCE)\nWHERE p1.province_id < p2.province_id\nRETURN b.type AS boundary_type, COUNT(*) AS shared_boundary_count, COLLECT({province1: p1.name, province2: p2.name}) AS province_pairs\nORDER BY shared_boundary_count DESC",
    "level_4_query": "MATCH (p1:PROVINCE)-[:SharesBorderWith]->(b:BOUNDARY)<-[:SharesBorderWith]-(p2:PROVINCE)\nWHERE p1.province_id < p2.province_id\nRETURN p1.name AS province1, p2.name AS province2, b.type AS shared_boundary_type, b.description\nORDER BY p1.name, p2.name"
  },
  {
    "instance_id": "instance_6",
    "gql_query": "MATCH (r:RIVER)-[:FlowsInto]->(s:SEA) WHERE r.length > 1000 RETURN r ORDER BY r.length DESC",
    "initial_nl": "Retrieve all rivers with a length greater than 1000 kilometers that flow into a sea, sorted by river length in descending order.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all nodes labeled 'RIVER' that have a relationship 'FlowsInto' directed to nodes labeled 'SEA', where the river's 'length' property is greater than 1000, and return these river nodes ordered by the 'length' property in descending order.",
    "level_2": "Retrieve all rivers longer than 1000 kilometers that flow into a sea, sorted from longest to shortest.",
    "level_3": "Identify and rank major rivers exceeding 1000 km in length based on their connectivity to seas to analyze geographic patterns in large river systems.",
    "level_4": "Support environmental and infrastructure planning by highlighting the longest rivers flowing into seas, which may influence navigation routes, ecological conservation priorities, or water resource management strategies.",
    "explanation": "The initial NL query focuses on the semantic meaning of the data retrieval without referencing graph-specific elements like nodes or relationships, placing it at Level 2. Level 1 reintroduces explicit graph terminology (labels, relationships, properties). Level 3 shifts to the analytical intent—studying large river systems and their geographic behavior. Level 4 elevates the context to real-world applications in environmental and strategic planning, emphasizing business or domain impact. This progression moves from syntactic structure to strategic insight.",
    "meta": {},
    "initial_query": "MATCH (r:RIVER)-[:FlowsInto]->(:SEA)\nWHERE r.length > 1000\nRETURN r.name, r.length\nORDER BY r.length DESC",
    "level_1_query": "MATCH (r:RIVER)-[:FlowsInto]->(s:SEA)\nWHERE r.length > 1000\nRETURN r\nORDER BY r.length DESC",
    "level_2_query": "MATCH (r:RIVER)-[:FlowsInto]->(:SEA)\nWHERE r.length > 1000\nRETURN r.name, r.length\nORDER BY r.length DESC",
    "level_3_query": "MATCH (r:RIVER)-[:FLOWS_INTO*1..]->(s:SEA)\nWHERE r.length > 1000\nRETURN r.name AS river_name, r.length AS length, s.name AS sea_name\nORDER BY r.length DESC",
    "level_4_query": "MATCH (r:RIVER)-[:FlowsInto]->(s:SEA)\nRETURN r.name AS river_name, s.name AS sea_name, r.length AS river_length\nORDER BY r.length DESC\nLIMIT 10"
  },
  {
    "instance_id": "instance_7",
    "gql_query": "MATCH (c:CITY)-[:LocatedIn]->(country:COUNTRY) RETURN country.name AS country_name, count(c) AS city_count, sum(c.population) AS total_population ORDER BY country_name",
    "initial_nl": "How many cities are located in each country, and what is the total population of cities per country?",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all CITY nodes connected to COUNTRY nodes via the 'LocatedIn' relationship, and for each COUNTRY node, return the country name, the count of connected CITY nodes, and the sum of the population property values of those cities, ordered by the country name.",
    "level_2": "How many cities are located in each country, and what is the total population of cities per country?",
    "level_3": "Aggregate city-level demographic data by country to analyze geographic distribution patterns and urban concentration across nations.",
    "level_4": "Support national infrastructure and resource allocation planning by providing insights into urban density and population distribution across countries.",
    "explanation": "The progression moves from syntactic graph components (Level 1: nodes, relationships, properties) to a semantically equivalent natural language question (Level 2). Level 3 shifts to the analytical intent—using aggregation to study spatial and demographic patterns. Level 4 elevates the purpose to strategic decision-making, emphasizing real-world applications in policy and planning. The initial NL query focuses on semantic meaning without referencing graph structures, placing it at Level 2.",
    "meta": {},
    "initial_query": "MATCH (c:Country)\nOPTIONAL MATCH (city:City)-[:LocatedIn]->(c)\nRETURN c.name AS country, COUNT(city) AS city_count, COALESCE(SUM(city.population), 0) AS total_city_population",
    "level_1_query": "MATCH (c:CITY)-[:LocatedIn]->(co:COUNTRY)\nRETURN co.name AS country_name, \n       COUNT(c) AS city_count, \n       SUM(c.population) AS total_city_population\nORDER BY co.name",
    "level_2_query": "MATCH (c:Country)\nOPTIONAL MATCH (city:City)-[:LocatedIn]->(c)\nRETURN c.name AS country, \n       COUNT(city) AS city_count, \n       COALESCE(SUM(city.population), 0) AS total_city_population\nORDER BY country",
    "level_3_query": "MATCH (c:CITY)-[:LocatedIn]->(co:COUNTRY)\nRETURN co.name AS country, COUNT(c) AS city_count, SUM(c.population) AS total_urban_population\nORDER BY total_urban_population DESC",
    "level_4_query": "MATCH (c: COUNTRY)<-[:LocatedIn*]-(city:CITY)\nRETURN c.name AS country, \n       COLLECT(city.name) AS cities, \n       SUM(city.population) AS total_urban_population,\n       COUNT(city) AS number_of_cities\nORDER BY total_urban_population DESC"
  },
  {
    "instance_id": "instance_8",
    "gql_query": "MATCH (r:RIVER)-[:FlowsInto]->(o:OCEAN) WHERE o.name = 'Pacific Ocean' RETURN r.name",
    "initial_nl": "Which rivers flow into the ocean named 'Pacific Ocean'?",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all nodes labeled 'RIVER' that have a 'FlowsInto' relationship directed to a node labeled 'OCEAN' where the 'name' property of the OCEAN node is 'Pacific Ocean', and return the 'name' property of the RIVER nodes.",
    "level_2": "Which rivers flow into the ocean named 'Pacific Ocean'?",
    "level_3": "Identify river systems connected to the Pacific Ocean to analyze hydrological networks and potential pathways for waterborne transport or ecological impact.",
    "level_4": "Support environmental planning and disaster management strategies by mapping freshwater sources contributing to the Pacific Ocean, aiding in pollution control, fisheries management, and climate resilience initiatives.",
    "explanation": "The initial NL query focuses on the semantic meaning of the data without referencing graph structures (e.g., nodes, relationships), placing it at Level 2. Level 1 explicitly includes graph syntax such as node labels, relationship types, and properties. Level 2 rephrases this into natural language understandable to non-technical users. Level 3 shifts to an analytical perspective, emphasizing the investigative strategy behind identifying river-ocean connectivity. Level 4 elevates the insight to real-world applications in environmental science and policy, highlighting strategic domain value.",
    "meta": {},
    "initial_query": "MATCH (r:RIVER)-[:FLOWSINTO]->(:OCEAN {name: 'Pacific Ocean'})\nRETURN r.name",
    "level_1_query": "MATCH (r:RIVER)-[:FlowsInto]->(o:OCEAN {name: 'Pacific Ocean'})\nRETURN r.name",
    "level_2_query": "MATCH (r:RIVER)-[:FlowsInto]->(o:OCEAN {name: 'Pacific Ocean'})\nRETURN r.name AS river_name",
    "level_3_query": "MATCH (o:OCEAN {name: \"Pacific Ocean\"})<-[:DrainsTo*]-(r:RIVER)\nRETURN DISTINCT r.name AS river_name, o.name AS ocean_name\nUNION\nMATCH (o:OCEAN {name: \"Pacific Ocean\"})<-[:FlowsInto*]-(r:RIVER)\nRETURN DISTINCT r.name AS river_name, o.name AS ocean_name",
    "level_4_query": "MATCH (r:RIVER)-[:FlowsInto]->(:OCEAN {name: \"Pacific Ocean\"})\nRETURN DISTINCT r.name AS river_name, r.river_id, r.length\nORDER BY r.length DESC"
  },
  {
    "instance_id": "instance_9",
    "gql_query": "MATCH (p:PROVINCE) WHERE p.population < 1000000 AND p.area > 10000 RETURN p.name ORDER BY p.area ASC",
    "initial_nl": "Retrieve the names of provinces with a population less than 1 million and an area greater than 10,000 square kilometers, sorted by area in ascending order.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all nodes labeled as PROVINCE that have a population property less than 1000000 and an area property greater than 10000, then return the name property of these nodes ordered by the area property in ascending order.",
    "level_2": "List the names of provinces with fewer than 1 million people and an area exceeding 10,000 square kilometers, sorted from smallest to largest by area.",
    "level_3": "Identify sparsely populated but geographically large provinces to analyze regional density patterns and explore potential outliers in land use or administrative efficiency.",
    "level_4": "Support regional planning and resource allocation decisions by highlighting underpopulated yet expansive provinces that may require targeted infrastructure investment or policy intervention.",
    "explanation": "The progression moves from syntactic graph elements (Level 1), which explicitly references node labels and properties, to a semantically equivalent natural language statement without graph jargon (Level 2). Level 3 shifts focus to the analytical intent—investigating geographic and demographic anomalies. Finally, Level 4 frames the query in terms of strategic governance and public policy impact, emphasizing real-world decision-making value.",
    "meta": {},
    "initial_query": "MATCH (p:PROVINCE)\nWHERE p.population < 1000000 AND p.area > 10000\nRETURN p.name\nORDER BY p.area ASC",
    "level_1_query": "MATCH (p:PROVINCE)\nWHERE p.population < 1000000 AND p.area > 10000\nRETURN p.name\nORDER BY p.area ASC",
    "level_2_query": "MATCH (p:PROVINCE)\nWHERE p.population < 1000000 AND p.area > 10000\nRETURN p.name\nORDER BY p.area ASC",
    "level_3_query": "MATCH (p:PROVINCE)\nWHERE p.population IS NOT NULL AND p.area IS NOT NULL\nWITH p, toFloat(p.population) / p.area AS density\nORDER BY density ASC\nRETURN p.name AS province_name, p.population, p.area, density AS population_density\nLIMIT 10;",
    "level_4_query": "MATCH (p:PROVINCE)\nWHERE p.population IS NOT NULL AND p.area IS NOT NULL\n  AND p.population < 1000000 AND p.area > 50000\nRETURN p.name AS province_name, p.population, p.area\nORDER BY p.area DESC, p.population ASC"
  },
  {
    "instance_id": "instance_10",
    "gql_query": "MATCH (c:COUNTRY)-[:HasForest]->(f:FOREST) RETURN c.name AS country, AVG(f.area) AS average_forest_area, SUM(f.area) AS total_forest_area ORDER BY total_forest_area DESC LIMIT 1",
    "initial_nl": "which country has the largest total forest area? What is the average area of forests and total forest area in that country?",
    "initial_nl_classification": "Level 2",
    "level_1": "Find a COUNTRY node connected via the HasForest relationship to FOREST nodes, retrieve the country's name, compute the average of the 'area' property across related FOREST nodes, sum the 'area' property values of all connected FOREST nodes, order the results by the total forest area in descending order, and return only the top result.",
    "level_2": "Which country has the largest total forest area, and what are the average forest area and total forest area in that country?",
    "level_3": "Identify the country with the most extensive forest coverage by aggregating forest areas and analyze the distribution of forest sizes within that country to understand spatial concentration patterns.",
    "level_4": "Determine the nation with the greatest forest resource capacity to inform environmental conservation strategies, carbon sequestration potential, and sustainable land-use planning on a global scale.",
    "explanation": "The initial NL query focuses on the semantic meaning of the query without referencing graph structures (e.g., nodes or relationships), placing it at Level 2. Level 1 introduces explicit graph elements like node labels (COUNTRY, FOREST), relationship type (HasForest), and property operations. Level 2 rephrases this into a natural question understandable to non-technical users. Level 3 shifts to the analytical intent—understanding not just 'which' but 'why' such aggregation matters in exploring geographic patterns. Finally, Level 4 elevates the insight to strategic, real-world applications in environmental policy and sustainability, emphasizing domain impact rather than data mechanics.",
    "meta": {},
    "initial_query": "MATCH (c:COUNTRY)-[:HasForest]->(f:FOREST)\nWITH c, SUM(f.area) AS total_forest_area, AVG(f.area) AS avg_forest_area\nORDER BY total_forest_area DESC\nLIMIT 1\nRETURN c.name, total_forest_area, avg_forest_area",
    "level_1_query": "MATCH (c:COUNTRY)-[:HasForest]->(f:FOREST)\nRETURN c.name, avg(f.area) AS average_forest_area, sum(f.area) AS total_forest_area\nORDER BY total_forest_area DESC\nLIMIT 1",
    "level_2_query": "MATCH (c:COUNTRY)-[:HasForest]->(f:FOREST)\nWITH c, SUM(f.area) AS total_forest_area, AVG(f.area) AS avg_forest_area\nORDER BY total_forest_area DESC\nLIMIT 1\nRETURN c.name, total_forest_area, avg_forest_area",
    "level_3_query": "MATCH (c:COUNTRY)-[:HasForest]->(f:FOREST)\nWITH c, SUM(f.area) AS total_forest_area\nORDER BY total_forest_area DESC\nLIMIT 1\nMATCH (c)-[:HasForest]->(f:FOREST)\nRETURN c.name AS country, total_forest_area, COLLECT(f.area) AS forest_sizes",
    "level_4_query": "MATCH (c:COUNTRY)-[:HasForest]->(f:FOREST)\nRETURN c.name AS country_name, SUM(f.area) AS total_forest_area\nORDER BY total_forest_area DESC\nLIMIT 1"
  },
  {
    "instance_id": "instance_11",
    "gql_query": "MATCH (c:CITY) WHERE c.area > 500 AND c.latitude >= 40 AND c.latitude <= 50 RETURN c ORDER BY c.longitude ASC",
    "initial_nl": "List cities having an area larger than 500 square kilometers and a latitude between 40 and 50 degrees, ordered by longitude from west to east.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all nodes labeled as CITY that have a property 'area' greater than 500, and whose 'latitude' property is between 40 and 50, inclusive, then return these nodes ordered by their 'longitude' property in ascending order.",
    "level_2": "List cities with an area larger than 500 square kilometers and located between latitudes 40 and 50 degrees, sorted from west to east based on increasing longitude.",
    "level_3": "Identify and analyze geographically dispersed cities of significant size within a specific mid-latitude band to study spatial distribution patterns across a longitudinal gradient.",
    "level_4": "Support urban development or logistics planning by identifying large cities in a target latitude zone, enabling strategic decisions about regional investments, transportation networks, or market expansion from west to east.",
    "explanation": "The initial NL query focuses on the semantic meaning of the data conditions without referencing graph structures (e.g., nodes, labels), placing it at Level 2. Level 1 explicitly includes graph terminology such as node labels (CITY) and properties. Level 2 rephrases this into natural geographic terms understandable to non-technical users. Level 3 shifts to an analytical perspective, emphasizing the investigation of spatial patterns. Level 4 connects the query to real-world strategic applications in urban planning or business expansion, highlighting domain impact and decision-making value.",
    "meta": {},
    "initial_query": "MATCH (c:CITY)\nWHERE c.area > 500 AND c.latitude >= 40 AND c.latitude <= 50\nRETURN c.name, c.longitude\nORDER BY c.longitude ASC",
    "level_1_query": "MATCH (c:CITY)\nWHERE c.area > 500 AND c.latitude >= 40 AND c.latitude <= 50\nRETURN c\nORDER BY c.longitude ASC",
    "level_2_query": "MATCH (c:CITY)\nWHERE c.area > 500 AND c.latitude >= 40 AND c.latitude <= 50\nRETURN c.name, c.longitude\nORDER BY c.longitude ASC",
    "level_3_query": "MATCH (c:CITY)\nWHERE c.latitude IS NOT NULL\n  AND c.population IS NOT NULL\n  AND c.latitude BETWEEN 30.0 AND 60.0\n  AND c.population >= 500000\nRETURN c.name AS city_name, c.latitude AS latitude, c.longitude AS longitude, c.population AS population\nORDER BY c.longitude",
    "level_4_query": "MATCH (c:CITY)\nWHERE c.latitude >= 35.0 AND c.latitude <= 40.0 AND c.population > 1000000\nRETURN c.name, c.city_id, c.latitude, c.longitude, c.population\nORDER BY c.longitude ASC"
  },
  {
    "instance_id": "instance_12",
    "gql_query": "MATCH (r:RIVER)-[:FlowsInto]->(o:OCEAN) WITH o, count(r) AS tributary_count RETURN o.name AS ocean_name, tributary_count ORDER BY tributary_count DESC LIMIT 1",
    "initial_nl": "Count the number of rivers that flow into each ocean, and identify the ocean with the highest number of tributaries.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all river nodes connected to ocean nodes via the 'FlowsInto' relationship, group by ocean, count the number of incoming river relationships per ocean, return the ocean name and the count, then sort in descending order and limit to the top result.",
    "level_2": "Which ocean receives the most rivers flowing into it, and how many rivers flow into it?",
    "level_3": "Analyze the distribution of river inflows across oceans to determine which ocean acts as the primary endpoint for river systems, using aggregation and ranking to identify dominant patterns in hydrological connectivity.",
    "level_4": "Identify the ocean that serves as the major drainage hub for global river networks to support environmental impact assessments, climate modeling, or resource management strategies related to freshwater inflow and marine ecosystem health.",
    "explanation": "The initial natural language query describes the logical operation (counting and identifying maximum) without referencing graph elements like nodes or relationships, placing it at Level 2. Level 1 explicitly includes graph syntax such as node labels (RIVER, OCEAN), relationship types (:FlowsInto), and query structure (WITH, RETURN, ORDER BY). Level 3 shifts focus to the analytical strategy—examining hydrological patterns through aggregation and ranking. Level 4 elevates the insight to real-world applications in environmental science and policy, emphasizing strategic value over technical or computational details.",
    "meta": {},
    "initial_query": "MATCH (r:RIVER)-[:FlowsInto]->(o:OCEAN)\nRETURN o.name AS ocean_name, COUNT(r) AS river_count\nORDER BY river_count DESC\nLIMIT 1",
    "level_1_query": "MATCH (r:RIVER)-[:FlowsInto]->(o:OCEAN)\nRETURN o.name AS ocean_name, COUNT(r) AS river_count\nORDER BY river_count DESC\nLIMIT 1",
    "level_2_query": "MATCH (r:RIVER)-[:FlowsInto]->(o:OCEAN)\nRETURN o.name AS ocean_name, COUNT(r) AS river_count\nORDER BY river_count DESC\nLIMIT 1",
    "level_3_query": "MATCH (r:RIVER)-[:FLOWS_INTO]->(o:OCEAN)\nRETURN o.name AS ocean_name, COUNT(r) AS river_count\nORDER BY river_count DESC",
    "level_4_query": "MATCH (o:OCEAN)\nWITH o, size((o)<-[:DrainsTo]-()) AS riverCount\nORDER BY riverCount DESC\nLIMIT 1\nRETURN o.name AS major_drainage_ocean, riverCount"
  },
  {
    "instance_id": "instance_13",
    "gql_query": "MATCH (m:MOUNTAIN)<-[:HasMountain]-(p:PROVINCE)-[:PartOf]->(r:REGION)-[:PartOf]->(c:CONTINENT) WHERE c.area > 10000000 RETURN m",
    "initial_nl": "List the mountains in provinces that are part of regions which belong to continents with an area greater than 10 million square kilometers.",
    "initial_nl_classification": "Level 2",
    "level_1": "Find all MOUNTAIN nodes connected via a HasMountain relationship to PROVINCE nodes, where each PROVINCE is linked by a PartOf relationship to a REGION, which in turn is linked by a PartOf relationship to a CONTINENT node with an area property greater than 10,000,000; return the MOUNTAIN nodes.",
    "level_2": "List the mountains located in provinces that are part of regions within continents having an area larger than 10 million square kilometers.",
    "level_3": "Identify mountain formations in provinces across large continental landmasses to analyze geographical distribution patterns based on continental size thresholds.",
    "level_4": "Support environmental planning and resource allocation by identifying significant mountain regions in the world's largest continents for conservation or tourism development strategies.",
    "explanation": "The initial natural language query focuses on the semantic meaning of the data relationships without referencing graph-specific syntax like labels or relationships explicitly, placing it at Level 2. Level 1 reintroduces explicit graph elements (node types, relationship types, properties). Level 3 shifts to the analytical intent—examining geographic patterns using size-based filtering. Level 4 elevates the purpose to strategic decision-making in environmental or economic domains, emphasizing real-world impact.",
    "meta": {},
    "initial_query": "MATCH (m:MOUNTAIN)-[:HasMountain]->(p:PROVINCE)-[:PartOf]->(r:REGION)-[:PartOf]->(c:CONTINENT)\nWHERE c.area > 10000000\nRETURN DISTINCT m.name AS mountain_name",
    "level_1_query": "MATCH (mountain:MOUNTAIN)-[:HasMountain]->(province:PROVINCE)-[:PartOf]->(region:REGION)-[:PartOf]->(continent:CONTINENT)\nWHERE continent.area > 10000000\nRETURN DISTINCT mountain",
    "level_2_query": "MATCH (m:MOUNTAIN)-[:LocatedIn]->(:PROVINCE)-[:PartOf]->(:REGION)-[:PartOf]->(c:CONTINENT)\nWHERE c.area > 10000000\nRETURN DISTINCT m.name AS mountain_name",
    "level_3_query": "MATCH (continent:CONTINENT)-[:Contains]->(province:PROVINCE)-[:HasMountain]->(mountain:MOUNTAIN)\nWHERE continent.area > 10000000.0\nRETURN DISTINCT continent.name AS continent, province.name AS province, COLLECT(mountain.name) AS mountains\nORDER BY continent, province",
    "level_4_query": "MATCH (c:CONTINENT)\nWITH c ORDER BY c.area DESC LIMIT 3\nMATCH (m:MOUNTAIN)-[:PartOf]->(c)\nRETURN DISTINCT c.name AS continent, m.name AS mountain, m.height AS height\nORDER BY c.name, m.height DESC"
  }
]